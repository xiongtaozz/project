1、技术主题(Python标准库：threading(*)和thread(底层)) Timer等

a、线程理解
	进程:
		进程之间不共享任何状态，进程的调度由操作系统完成，每个进程都有自己独立的内存空间，
		进程间通讯主要是通过信号传递的方式来实现的，实现方式有多种，信号量、管道、事件等，
		任何一种方式的通讯效率都需要过内核，导致通讯效率比较低。由于是独立的内存空间，
		上下文切换的时候需要保存先调用栈的信息、cpu各寄存器的信息、虚拟内存、以及打开的相关句柄等信息，
		所以导致上下文进程间切换开销很大，通讯麻烦。
	线程: (锁机制)
		线程之间共享变量，解决了通讯麻烦的问题，但是对于变量的访问需要锁，线程的调度主要也是有操作系统完成，
		一个进程可以拥有多个线程，但是其中每个线程会共享父进程像操作系统申请资源，这个包括虚拟内存、文件等，
		由于是共享资源，所以创建线程所需要的系统资源占用比进程小很多，相应的可创建的线程数量也变得相对多很多。
		线程时间的通讯除了可以使用进程之间通讯的方式以外还可以通过共享内存的方式进行通信，
		所以这个速度比通过内核要快很多。另外在调度方面也是由于内存是共享的，所以上下文切换的时候需要保存的东西
		就像对少一些，这样一来上下文的切换也变得高效。
	协程:
		协程的调度完全由用户控制，一个线程可以有多个协程，用户创建了几个线程，然后每个线程都是循环按照指定的任务
		清单顺序完成不同的任务，当任务被堵塞的时候执行下一个任务，当恢复的时候再回来执行这个任务，任务之间的切换
		只需要保存每个任务的上下文内容，就像直接操作栈一样的，这样就完全没有内核切换的开销，可以不加锁的访问全局
		变量，所以上下文的切换非常快；另外协程还需要保证是非堵塞的且没有相互依赖，协程基本上不能同步通讯，多采用
		一步的消息通讯，效率比较高。

	进程 ---> 资源分配最小的单位(耗费资源比较多)
	线程 ---> CPU时间分配最小的单位（可协调cpu的性能）
	同时去执行多个任务。同时...cpu分配时间任务的时候是随机的。
	#12345 23415
b、threading和thread，Timer...，线程使用 + 线程的相关常用方法 + 线程同步（wait，notify...）+ 线程的锁机制

c、把爬虫单线程变成多线程

注意: Python里面的线程都是伪线程

2、学习交流&学习进度检查&自由交流&答疑

资料：

https://docs.python.org/2/library/threading.html?highlight=threading#module-threading

http://www.jb51.net/article/57672.htm

https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/

Thread-4Thread-3Thread-1Thread-2Thread-5
Thread-2Thread-1Thread-5Thread-4Thread-3
Thread-1Thread-3Thread-4Thread-2Thread-5